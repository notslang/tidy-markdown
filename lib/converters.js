// Generated by CoffeeScript 1.12.7
'use_strict'
var CODE_HIGHLIGHT_REGEX, _, delimitCode, extractRows, fallback, formatHeaderSeparator, formatRow, getAttribute, getColumnWidths, indent, indentChildren, insertText, insertTextBefore, isBlock, isTextNode, isValidLink, languageCodeRewrite, noExtraAttributes, ref, ref1, serialize, treeAdapter,
  indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }

_ = require('lodash')

indent = require('indent')

serialize = require('parse5').serialize

languageCodeRewrite = require('../lib/language-code-rewrites')

treeAdapter = require('./tree-adapter')

ref = require('./utils'), delimitCode = ref.delimitCode, getAttribute = ref.getAttribute, noExtraAttributes = ref.noExtraAttributes, isBlock = ref.isBlock

ref1 = require('./tables'), extractRows = ref1.extractRows, formatHeaderSeparator = ref1.formatHeaderSeparator, formatRow = ref1.formatRow, getColumnWidths = ref1.getColumnWidths

CODE_HIGHLIGHT_REGEX = /(?:highlight highlight|lang(?:uage)?)-(\S+)/

insertTextBefore = treeAdapter.insertTextBefore, insertText = treeAdapter.insertText, isTextNode = treeAdapter.isTextNode

indentChildren = function (node) {
  var allChildrenAreElements, child, children, j, k, l, len, len1, len2, ref2, ref3
  allChildrenAreElements = true
  ref2 = node.childNodes
  for (j = 0, len = ref2.length; j < len; j++) {
    child = ref2[j]
    if (isTextNode(child)) {
      allChildrenAreElements = false
    }
  }
  if (allChildrenAreElements) {
    children = []
    ref3 = node.childNodes
    for (k = 0, len1 = ref3.length; k < len1; k++) {
      child = ref3[k]
      children.push(child)
    }
    for (l = 0, len2 = children.length; l < len2; l++) {
      child = children[l]
      insertTextBefore(node, '\n  ', child)
    }
    return insertText(node, '\n')
  }
}

isValidLink = function (link) {
  return /.+(?:@|:\/).+/.test(link)
}

fallback = function () {
  return true
}

/**
 * This array holds a set of "converters" that process DOM nodes and output
   Markdown. The `filter` property determines what nodes the converter is run
   on. The `replacement` function takes the content of the node and the node
   itself and returns a string of Markdown. The `surroundingBlankLines` option
   determines whether or not the block should have a blank line before and after
   it. Converters are matched to nodes starting from the top of the converters
   list and testing each one downwards.
 * @type {Array}
 */

module.exports = [
  {
    filter: function (node) {
      var ref2, ref3
      return ((ref2 = node.parentNode) != null ? (ref3 = ref2._converter) != null ? ref3.filter : void 0 : void 0) === fallback
    },
    surroundingBlankLines: false,
    replacement: function (content, node) {
      indentChildren(node)
      return ''
    }
  }, {
    filter: 'p',
    surroundingBlankLines: true,
    replacement: function (content) {
      return content
    }
  }, {
    filter: ['td', 'th'],
    surroundingBlankLines: false,
    replacement: function (content) {
      return content
    }
  }, {
    filter: ['tbody', 'thead', 'tr'],
    surroundingBlankLines: false,
    replacement: function () {
      return ''
    }
  }, {
    filter: ['del', 's', 'strike'],
    surroundingBlankLines: false,
    replacement: function (content) {
      return '~~' + content + '~~'
    }
  }, {
    filter: ['em', 'i'],
    surroundingBlankLines: false,
    replacement: function (content) {
      if (indexOf.call(content, '_') >= 0) {
        return '*' + content + '*'
      } else {
        return '_' + content + '_'
      }
    }
  }, {
    filter: ['strong', 'b'],
    surroundingBlankLines: false,
    replacement: function (content) {
      return '**' + content + '**'
    }
  }, {
    filter: 'br',
    surroundingBlankLines: false,
    trailingWhitespace: '\n',
    replacement: function () {
      return '<br>'
    }
  }, {
    filter: 'a',
    surroundingBlankLines: false,
    replacement: function (content, node, links) {
      var referenceLink, title, url
      url = getAttribute(node, 'href') || ''
      title = getAttribute(node, 'title')
      referenceLink = _.find(links, {
        url: url,
        title: title
      })
      if (referenceLink) {
        if (content.toLowerCase() === referenceLink.name) {
          return '[' + content + ']'
        } else {
          return '[' + content + '][' + referenceLink.name + ']'
        }
      } else if (title) {
        return '[' + content + '](' + url + ' "' + title + '")'
      } else if (isValidLink(url) && (content === url || content === url.replace(/^mailto:/, ''))) {
        return '<' + content + '>'
      } else {
        return '[' + content + '](' + url + ')'
      }
    }
  }, {
    filter: function (node) {
      return node.tagName === 'img' && noExtraAttributes(node, 'alt', 'src', 'title')
    },
    surroundingBlankLines: false,
    replacement: function (content, node, links) {
      var alt, referenceLink, title, url
      alt = getAttribute(node, 'alt') || ''
      url = getAttribute(node, 'src') || ''
      title = getAttribute(node, 'title')
      referenceLink = _.find(links, {
        url: url,
        title: title
      })
      if (referenceLink) {
        if (alt.toLowerCase() === referenceLink.name) {
          return '![' + alt + ']'
        } else {
          return '![' + alt + '][' + referenceLink.name + ']'
        }
      } else if (title) {
        return '![' + alt + '](' + url + ' "' + title + '")'
      } else {
        return '![' + alt + '](' + url + ')'
      }
    }
  }, {
    filter: function (node) {
      return node.type === 'checkbox' && node.parentNode.tagName === 'li'
    },
    surroundingBlankLines: false,
    replacement: function (content, node) {
      return (node.checked ? '[x]' : '[ ]') + ' '
    }
  }, {
    filter: 'table',
    surroundingBlankLines: true,
    replacement: function (content, node) {
      var alignments, columnWidths, i, j, out, ref2, ref3, rows, totalCols
      ref2 = extractRows(node), alignments = ref2.alignments, rows = ref2.rows
      columnWidths = getColumnWidths(rows)
      totalCols = rows[0].length
      out = [formatRow(rows[0], alignments, columnWidths), formatHeaderSeparator(alignments, columnWidths)]
      for (i = j = 1, ref3 = rows.length; 1 <= ref3 ? j < ref3 : j > ref3; i = 1 <= ref3 ? ++j : --j) {
        out.push(formatRow(rows[i], alignments, columnWidths))
      }
      return out.join('\n')
    }
  }, {
    filter: 'pre',
    surroundingBlankLines: true,
    replacement: function (content, node) {
      var language, ref2, ref3, ref4, ref5, ref6
      if (((ref2 = node.childNodes[0]) != null ? ref2.tagName : void 0) === 'code') {
        language = (ref3 = getAttribute(node.childNodes[0], 'class')) != null ? (ref4 = ref3.match(CODE_HIGHLIGHT_REGEX)) != null ? ref4[1] : void 0 : void 0
      }
      if ((language == null) && node.parentNode.tagName === 'div') {
        language = (ref5 = getAttribute(node.parentNode, 'class')) != null ? (ref6 = ref5.match(CODE_HIGHLIGHT_REGEX)) != null ? ref6[1] : void 0 : void 0
      }
      if (language != null) {
        language = language.toLowerCase()
        if (languageCodeRewrite[language] != null) {
          language = languageCodeRewrite[language]
        }
      }
      return delimitCode((language || '') + '\n' + content + '\n', '```')
    }
  }, {
    filter: 'code',
    surroundingBlankLines: false,
    replacement: function (content, node) {
      if (node.parentNode.tagName !== 'pre') {
        return delimitCode(content, '`')
      } else {
        return content
      }
    }
  }, {
    filter: function (node) {
      return node.tagName === 'div' && CODE_HIGHLIGHT_REGEX.test(node.className)
    },
    surroundingBlankLines: true,
    replacement: function (content) {
      return content
    }
  }, {
    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
    surroundingBlankLines: true,
    replacement: function (content, node) {
      var hLevel
      hLevel = node.tagName[1]
      return ('#'.repeat(hLevel)) + ' ' + content
    }
  }, {
    filter: 'hr',
    surroundingBlankLines: true,
    replacement: function () {
      return '-'.repeat(80)
    }
  }, {
    filter: 'blockquote',
    surroundingBlankLines: true,
    replacement: function (content) {
      return indent(content, '> ')
    }
  }, {
    filter: 'li',
    surroundingBlankLines: false,
    trailingWhitespace: '\n',
    replacement: function (content, node) {
      var parent, prefix
      if (indexOf.call(content, '\n') >= 0) {
        content = indent(content, '  ').trimLeft()
      }
      parent = node.parentNode
      prefix = (parent.tagName === 'ol' ? parent.childNodes.indexOf(node) + 1 + '. ' : '- ')
      return prefix + content
    }
  }, {
    filter: ['ul', 'ol'],
    surroundingBlankLines: true,
    replacement: function (content) {
      return content
    }
  }, {
    filter: '_comment',
    replacement: function (content) {
      return '<!-- ' + content + ' -->'
    }
  }, {
    filter: fallback,
    surroundingBlankLines: true,
    replacement: function (content, node) {
      indentChildren(node)
      return serialize({
        children: [node],
        nodeName: '#document-fragment',
        quirksMode: false
      }, {
        treeAdapter: treeAdapter
      })
    }
  }
]
