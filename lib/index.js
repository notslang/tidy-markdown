// Generated by CoffeeScript 1.12.7
'use_strict'
var _, bfsOrder, canConvert, cleanText, convertCommentNode, converters, createElement, decodeHtmlEntities, detachNode, findConverter, fixHeaders, flankingWhitespace, fm, getCommentNodeContent, getContent, getTextNodeContent, insertBefore, insertText, isBlock, isCommentNode, isElementNode, isFlankedByWhitespace, isTextNode, isVoid, marked, parseFragment, process, ref, removeEmptyNodes, treeAdapter, yaml,
  indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }

_ = require('lodash')

fm = require('front-matter')

marked = require('marked')

yaml = require('js-yaml')

parseFragment = require('parse5').parseFragment

converters = require('./converters')

treeAdapter = require('./tree-adapter')

ref = require('./utils'), cleanText = ref.cleanText, decodeHtmlEntities = ref.decodeHtmlEntities, isBlock = ref.isBlock, isVoid = ref.isVoid

createElement = treeAdapter.createElement, detachNode = treeAdapter.detachNode, getCommentNodeContent = treeAdapter.getCommentNodeContent, getTextNodeContent = treeAdapter.getTextNodeContent, insertBefore = treeAdapter.insertBefore, insertText = treeAdapter.insertText, isCommentNode = treeAdapter.isCommentNode, isElementNode = treeAdapter.isElementNode, isTextNode = treeAdapter.isTextNode

/**
 * Some people accidently skip levels in their headers (like jumping from h1 to
   h3), which screws up things like tables of contents. This function fixes
   that.
 * The algorithm assumes that relations between nearby headers are correct and
   will try to preserve them. For example, "h1, h3, h3" becomes "h1, h2, h2"
   rather than "h1, h2, h3".
 */

fixHeaders = function (dom, ensureFirstHeaderIsH1) {
  var child, childHeaderDepth, e, gap, headerDepth, i, j, k, lastHeaderDepth, len, ref1, ref2, ref3, rootDepth, topLevelHeaders
  topLevelHeaders = []
  ref1 = dom.childNodes
  for (j = 0, len = ref1.length; j < len; j++) {
    child = ref1[j]
    if (/h[0-6]/.test(child.tagName)) {
      topLevelHeaders.push(child)
    }
  }
  if (topLevelHeaders.length === 0) {
    return
  }
  lastHeaderDepth = 0
  if (!ensureFirstHeaderIsH1) {
    lastHeaderDepth = topLevelHeaders[0].tagName[1] - 1
  }
  rootDepth = lastHeaderDepth + 1
  i = 0
  while (i < topLevelHeaders.length) {
    headerDepth = parseInt(topLevelHeaders[i].tagName[1])
    if ( (rootDepth <= headerDepth && headerDepth <= lastHeaderDepth + 1)) {
      lastHeaderDepth = headerDepth
    } else {
      if (headerDepth <= rootDepth) {
        gap = headerDepth - rootDepth
      } else {
        gap = headerDepth - (lastHeaderDepth + 1)
      }
      for (e = k = ref2 = i, ref3 = topLevelHeaders.length; ref2 <= ref3 ? k < ref3 : k > ref3; e = ref2 <= ref3 ? ++k : --k) {
        childHeaderDepth = parseInt(topLevelHeaders[e].tagName[1])
        if (childHeaderDepth >= headerDepth) {
          topLevelHeaders[e].tagName = 'h' + (childHeaderDepth - gap)
        } else {
          break
        }
      }
      continue
    }
    i++
  }
}

convertCommentNode = function (node) {
  var commentElement
  commentElement = createElement('_comment', null, [])
  insertText(commentElement, getCommentNodeContent(node))
  insertBefore(node.parent, commentElement, node)
  detachNode(node)
  return commentElement
}

/**
 * Flattens DOM tree into single array
 */

bfsOrder = function (node) {
  var child, elem, inqueue, j, len, outqueue, ref1
  inqueue = [node]
  outqueue = []
  while (inqueue.length > 0) {
    elem = inqueue.shift()
    outqueue.push(elem)
    ref1 = elem.childNodes
    for (j = 0, len = ref1.length; j < len; j++) {
      child = ref1[j]
      if (isCommentNode(child)) {
        child = convertCommentNode(child)
      }
      if (isElementNode(child)) {
        inqueue.push(child)
      }
    }
  }
  outqueue.shift()
  return outqueue
}

/**
 * Contructs a Markdown string of replacement text for a given node
 */

getContent = function (node) {
  var child, childText, content, j, len, previousSibling, ref1, ref2, ref3, whitespaceSeparator
  if (isTextNode(node)) {
    return getTextNodeContent(node)
  }
  content = ''
  previousSibling = null
  ref1 = node.childNodes
  for (j = 0, len = ref1.length; j < len; j++) {
    child = ref1[j]
    childText = ((function () {
      if (isElementNode(child)) {
        return child._replacement
      } else if (isTextNode(child)) {
        return cleanText(child)
      } else {
        throw new Error('Unsupported node type: ' + child.type)
      }
    })())
    if (child.tagName === 'br') {
      content = content.trimRight()
    }
    if ((previousSibling != null ? previousSibling.tagName : void 0) === 'br') {
      childText = childText.trimLeft()
    }
    if (previousSibling != null) {
      whitespaceSeparator = ((((ref2 = child._whitespace) != null ? ref2.leading : void 0) || '') + ((previousSibling != null ? (ref3 = previousSibling._whitespace) != null ? ref3.trailing : void 0 : void 0) || '')).replace(/\n{3,}/, '\n\n')
      content += whitespaceSeparator
    }
    content += childText
    previousSibling = child
  }
  return content
}

canConvert = function (node, filter) {
  var ref1
  if (typeof filter === 'string') {
    return filter === node.tagName
  } else if (Array.isArray(filter)) {
    return ref1 = node.tagName, indexOf.call(filter, ref1) >= 0
  } else if (typeof filter === 'function') {
    return filter(node)
  } else {
    throw new TypeError('`filter` needs to be a string, array, or function')
  }
}

findConverter = function (node) {
  var converter, j, len
  for (j = 0, len = converters.length; j < len; j++) {
    converter = converters[j]
    if (canConvert(node, converter.filter)) {
      return converter
    }
  }
}

isFlankedByWhitespace = function (side, node) {
  var regExp, sibling
  if (side === 'left') {
    sibling = node.previousSibling
    regExp = /\s$/
  } else {
    sibling = node.nextSibling
    regExp = /^\s/
  }
  if (sibling && !isBlock(sibling)) {
    return regExp.test(getContent(sibling))
  } else {
    return false
  }
}

flankingWhitespace = function (node) {
  var content, hasLeading, hasTrailing, leading, ref1, ref2, ref3, ref4, trailing
  leading = ''
  trailing = ''
  if (!isBlock(node)) {
    content = getContent(node)
    hasLeading = /^\s/.test(content)
    hasTrailing = /\s$/.test(content)
    if (hasLeading && !isFlankedByWhitespace('left', node)) {
      leading = ' '
    }
    if (hasTrailing && !isFlankedByWhitespace('right', node)) {
      trailing = ' '
    }
  }
  if ((ref1 = node.childNodes[0]) != null ? (ref2 = ref1._whitespace) != null ? ref2.leading : void 0 : void 0) {
    leading += node.childNodes[0]._whitespace.leading
  }
  if ((ref3 = node.childNodes.slice(-1)[0]) != null ? (ref4 = ref3._whitespace) != null ? ref4.trailing : void 0 : void 0) {
    trailing += node.childNodes.slice(-1)[0]._whitespace.trailing
  }
  return {
    leading: leading,
    trailing: trailing
  }
}

/*
 * Finds a Markdown converter, gets the replacement, and sets it on
 * `_replacement`
 */

process = function (node, links) {
  var content, converter, whitespace
  content = getContent(node).trim()
  converter = node._converter
  if (converter.surroundingBlankLines) {
    whitespace = {
      leading: '\n\n',
      trailing: '\n\n'
    }
  } else {
    whitespace = flankingWhitespace(node)
    if (converter.trailingWhitespace != null) {
      whitespace.trailing += converter.trailingWhitespace
    }
  }
  if (node.tagName === 'li') {
    whitespace.leading = ''
  }
  node._replacement = converter.replacement(content, node, links)
  node._whitespace = whitespace
}

/**
 * Remove whitespace text nodes from children
 */

removeEmptyNodes = function (node) {
  var child, emptyChildren, j, k, len, len1, nextSibling, previousSibling, ref1
  emptyChildren = []
  ref1 = node.childNodes
  for (j = 0, len = ref1.length; j < len; j++) {
    child = ref1[j]
    if (isTextNode(child) && getTextNodeContent(child).trim() === '') {
      previousSibling = child.previousSibling
      nextSibling = child.nextSibling
      if (!previousSibling || !nextSibling || isBlock(previousSibling) || isBlock(nextSibling)) {
        emptyChildren.push(child)
      }
    }
  }
  for (k = 0, len1 = emptyChildren.length; k < len1; k++) {
    child = emptyChildren[k]
    detachNode(child)
  }
}

module.exports = function (dirtyMarkdown, options) {
  var ast, content, html, j, k, l, len, len1, len2, link, links, m, name, node, nodes, optionalTitle, out, rawLinks, ref1, root, title, url, value
  if (options == null) {
    options = {}
  }
  if (typeof dirtyMarkdown !== 'string') {
    throw new TypeError('Markdown input is not a string')
  }
  if (options.ensureFirstHeaderIsH1 == null) {
    options.ensureFirstHeaderIsH1 = true
  }
  out = ''
  try {
    content = fm(dirtyMarkdown)
    if (Object.keys(content.attributes).length !== 0) {
      out += '---\n' + yaml.safeDump(content.attributes).trim() + '\n---\n\n'
    }
    content = content.body
  } catch (error) {
    content = dirtyMarkdown
  }
  ast = marked.lexer(content)
  rawLinks = ast.links
  links = []
  for (link in rawLinks) {
    value = rawLinks[link]
    links.push({
      name: link.toLowerCase(),
      url: value.href,
      title: value.title || null
    })
  }
  links = _.sortBy(links, ['name', 'url'])
  html = marked.parser(ast)
  html = html.replace(/(\d+)\. /g, '$1\\. ')
  root = parseFragment(html, {
    treeAdapter: treeAdapter
  })
  removeEmptyNodes(root)
  fixHeaders(root, options.ensureFirstHeaderIsH1)
  nodes = bfsOrder(root)
  for (j = 0, len = nodes.length; j < len; j++) {
    node = nodes[j]
    removeEmptyNodes(node)
  }
  for (k = 0, len1 = nodes.length; k < len1; k++) {
    node = nodes[k]
    node._converter = findConverter(node)
  }
  for (l = nodes.length - 1; l >= 0; l += -1) {
    node = nodes[l]
    process(node, links)
  }
  out += getContent(root).trimRight() + '\n'
  if (links.length > 0) {
    out += '\n'
  }
  for (m = 0, len2 = links.length; m < len2; m++) {
    ref1 = links[m], name = ref1.name, url = ref1.url, title = ref1.title
    optionalTitle = title ? ' "' + title + '"' : ''
    out += '[' + name + ']: ' + url + optionalTitle + '\n'
  }
  return out
}
